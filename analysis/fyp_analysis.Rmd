---
title: "fyp_analysis"
output: html_document
---
```{r}
library(rjson)
library(ggplot2)
library(tidyr)
library(dplyr)
library(lme4)
library(lmerTest)
```

#Read files:
```{r}
data_location = "../data/fyp_1_data/" 
files = list.files(path = data_location,pattern="data_subject_.*.json")
modular_data = vector()
polygon_data = vector()
modular_prompt_data = vector()
polygon_prompt_data = vector()
#data frame building
subject = vector()
prompt = vector()
correct_response = vector()
rt = vector()
response = vector()
condition = vector()
trial_index = vector()
score = vector()

j = 1
for (i in 1:length(files)) {
  path = paste(data_location,files[i],sep="")
  print(i)
  print(path)
  c = file(path, "r")
  l = readLines(c, -1L)
  close(c)
  these_data = lapply(X=l, fromJSON)
  if (these_data[1][[1]][[1]]$trial_type == "instructions") {
    if (length(these_data[1][[1]]) == 85 || length(these_data[1][[1]]) == 105) { #The OR checks for people who had to repeat the initial training
      this_condition = "modular"
      modular_data[length(modular_data) + 1] = these_data[1]
    }
    else {
      this_condition = "modular_prompt"
      modular_prompt_data[length(modular_prompt_data) + 1] = these_data[1]
    }
  } else {
    if (length(these_data[1][[1]]) == 85 || length(these_data[1][[1]]) == 105) { #The OR checks for people who had to repeat the initial training
     this_condition = "polygon"
     polygon_data[length(polygon_data) + 1] = these_data[1]
    }
    else {
     this_condition = "polygon_prompt"
     polygon_prompt_data[length(polygon_prompt_data) + 1] = these_data[1]
    }
  }
  
  for (trial_i in 1:length(these_data[1][[1]])) {
    if(grepl("question",gsub(" ","",these_data[1][[1]][[trial_i]]$trial_type))) {
      subject[j] = i
      condition[j] = this_condition
      prompt[j] = these_data[1][[1]][[trial_i]]$question
      correct_response[j] = these_data[1][[1]][[trial_i]]$correct_response
      
      response[j] = these_data[1][[1]][[trial_i]]$response
      if (response[j] == correct_response[j]) {
        score[j] = 1
      } else {
        score[j] = 0        
      }
      rt[j] = these_data[1][[1]][[trial_i]]$rt
      trial_index[j] = trial_i
      
      j = j+1
    }
  }
}
```

Write data for scoring
----------------------------

```{r}
#DONE --exact answers, explanations not yet scored
#n=9 operation questions
#write.table(complete_data[(grepl("Whatis8",gsub(" ","",complete_data$question)) | grepl("Whatis4",gsub(" ","",complete_data$question)))& grepl("explaininwords",gsub(" ","",complete_data$question)) ,c(1,3,4,5,7)],"N9_operation_to_score.csv",sep=",")

#DONE --exact answers, explanations not yet scored
#n=9 generator questions
# write.table(complete_data[grepl("generatorunder",gsub(" ","",complete_data$question)) & (grepl("nonagon",gsub(" ","",complete_data$question)) | grepl("+<sub>9",gsub(" ","",complete_data$question)) ),c(1,3,4,5,7)],"N9_generator_to_score.csv",sep=",")

#DONE --exact answers, explanations not yet scored
#n=9 inverse with explanations
#write.table(complete_data[grepl("inverseof3",gsub(" ","",complete_data$question)) & (grepl("nonagon",gsub(" ","",complete_data$question)) | grepl("+<sub>9",gsub(" ","",complete_data$question)) ),c(1,4,5,7)],"N9_inverse_to_score.csv",sep=",")

#DONE --exact answers, explanations not yet scored
#generator T/F and A/S/N with explanations
#write.table(complete_data[grepl("explaininwords",gsub(" ","",complete_data$question)) & (grepl("Trueorfalse",gsub(" ","",complete_data$question)) | grepl("always,sometimes,ornever",gsub(" ","",complete_data$question))),c(1,4,5,7)],"TF_ASN_explained_to_score.csv",sep=",")

#DONE -- exact answers, explanations not yet scored
#n-1,n-x
#write.table(complete_data[grepl("formula",gsub(" ","",complete_data$question)),c(1,4,5,7)],"inverse_formula_to_score.csv",sep=",")
```

data frame building
------------------------
```{r}
complete_data = data.frame(subject=factor(subject),condition=condition,question=prompt,correct_response=correct_response,response=response,rt=rt,trial_index=trial_index,score=score) 

#Insert scored data
inverse_formula_scores = read.csv(paste(data_location,"inverse_formula_scored.csv",sep=""))
complete_data[inverse_formula_scores$row.names,]$score = inverse_formula_scores$score

TF_ASN_explained_scores = read.csv(paste(data_location,"TF_ASN_explained_scored.csv",sep=""))
complete_data[TF_ASN_explained_scores$row.names,]$score = TF_ASN_explained_scores$score

N9_operation_scores =read.csv(paste(data_location,"N9_operation_scored.csv",sep=""))
complete_data[N9_operation_scores$row.names,]$score = N9_operation_scores$score
N9_operation_scores[grepl("Whatis4",gsub(" ","",N9_operation_scores$question)),]$correct_response = 5
N9_operation_scores[grepl("Whatis8",gsub(" ","",N9_operation_scores$question)),]$correct_response = 3
complete_data[N9_operation_scores$row.names,]$correct_response = N9_operation_scores$correct_response #omitted because of answer explanation

N9_generator_scores = read.csv(paste(data_location,"N9_generator_scored.csv",sep=""))
complete_data[N9_generator_scores$row.names,]$score = N9_generator_scores$score

N9_inverse_scores =read.csv(paste(data_location,"N9_inverse_scored.csv",sep=""))
complete_data[N9_inverse_scores$row.names,]$score = N9_inverse_scores$score
complete_data[N9_inverse_scores$row.names,]$correct_response = 6 #omitted because of answer explanation

#Strict scoring -- Some questions have "partial credit" of 0.5 for almost correct answers
complete_data = complete_data %>% mutate(score_strict = floor(score)) %>% 
  mutate(polygon=grepl("polygon",condition),prompt=grepl("prompt",condition)) #Factors of condition


```


#Autoscoring
-----------------------------------------
Polygon:
```{r}
op_train_scores = vector()
op_retrain_scores = vector()
op_retrained = vector()
inverse_train_scores = vector()
generator_train_scores = vector()
op_test_scores = vector()
op_retested = vector()
inverse_test_scores = vector()
generator_test_scores = vector()

generator_tf_n_scores = vector() #True/False generator questions
generator_asn_n_scores = vector() #Always/Sometimes/Never generator questions

for (subj_i in 1:length(polygon_data)){
  offset = 0
  retrained = FALSE

  if (gsub(" ","",polygon_data[[subj_i]][[22]]$trial_type) != "polygon-arrow-instructions") { #Check whether subject had to do second operation training round, if yes, add offset, etc.
    offset = 20
    retrained = TRUE
  }

  #Training:
  #Operation
  num_train_probs = 10
   
  op_train_score = 0
  for (prob_i in seq(2,20,2)) { #Every other "trial" is a feedback screen
    if (polygon_data[[subj_i]][[prob_i]]$response == polygon_data[[subj_i]][[prob_i]]$correct_response) {
      op_train_score = op_train_score + 1
    }
  }
  op_train_score = 100*op_train_score/num_train_probs
  
  if (retrained) {
    op_retrain_score = 0
    for (prob_i in seq(22,40,2)) { #Every other "trial" is a feedback screen
      if (polygon_data[[subj_i]][[prob_i]]$response == polygon_data[[subj_i]][[prob_i]]$correct_response) {
        op_retrain_score = op_retrain_score + 1
      }
    }
    op_retrain_score = 100*op_retrain_score/num_train_probs
  }
  
  #Inverses
  inverse_train_score = 0
  for (prob_i in seq(24+offset,32+offset,2)) { #Every other "trial" is a feedback screen
    if (polygon_data[[subj_i]][[prob_i]]$response == polygon_data[[subj_i]][[prob_i]]$correct_response) {
      inverse_train_score = inverse_train_score + 1
    }
  }
  inverse_train_score = 100*inverse_train_score/5
  
  #Generators
  generator_train_score = 0
  for (prob_i in seq(36+offset,42+offset,2)) { #Every other "trial" is a feedback screen
    if (polygon_data[[subj_i]][[prob_i]]$response == polygon_data[[subj_i]][[prob_i]]$correct_response) {
      generator_train_score = generator_train_score + 1
    }
  }
  generator_train_score = 100*generator_train_score/4
  
  #Testing:
  #Operation

  polygon_data[[subj_i]][[52+offset]]$correct_response = "5" #Left blank because of explain answer
  polygon_data[[subj_i]][[53+offset]]$correct_response = "3" #Left blank because of explain answer
  
  op_test_score = 0
  for (prob_i in seq(47+offset,53+offset,1)) {
    if (substr(polygon_data[[subj_i]][[prob_i]]$response,1,1) == polygon_data[[subj_i]][[prob_i]]$correct_response) { #Substr is to deal with appended explanations.
      op_test_score = op_test_score + 1
    }
  }
  op_test_score = 100*op_test_score/7
  
  #Inverses
  polygon_data[[subj_i]][[57+offset]]$correct_response = "6" #Left blank because of explain answer
    
  inverse_test_score = 0
  for (prob_i in seq(55+offset,56+offset,1)) {
    if (substr(polygon_data[[subj_i]][[prob_i]]$response,1,1) == polygon_data[[subj_i]][[prob_i]]$correct_response) {
      inverse_test_score = inverse_test_score + 1
    }
  }
  inverse_test_score = 100*inverse_test_score/2
  
  #Generators
  generator_test_score = 0
  #for (prob_i in seq(36+offset,42+offset,2)) { #Every other "trial" is a feedback screen
  #  if (polygon_data[[subj_i]][[prob_i]]$response == polygon_data[[subj_i]][[prob_i]]$correct_response) {
  #    generator_test_score = generator_test_score + 1
  #  }
  #}
  #generator_test_score = 100*generator_test_score/4  

  #Generic testing  
  generator_tf_n_score = 0
  for (prob_i in seq(66+offset,68+offset,1)) { #Every other "trial" is a feedback screen
   if (polygon_data[[subj_i]][[prob_i]]$response == polygon_data[[subj_i]][[prob_i]]$correct_response) {
     generator_tf_n_score = generator_tf_n_score + 1
   }
  }
  generator_tf_n_score = 100*generator_tf_n_score/3    
  
  generator_asn_n_score = 0
  for (prob_i in seq(70+offset,71+offset,1)) { #Every other "trial" is a feedback screen
   if (polygon_data[[subj_i]][[prob_i]]$response == polygon_data[[subj_i]][[prob_i]]$correct_response) {
     generator_asn_n_score = generator_asn_n_score + 1
   }
  }
  generator_asn_n_score = 100*generator_asn_n_score/2    
  
  #Add this subject's data to lists used to build frame
  op_train_scores[subj_i] = op_train_score
  if (retrained) {
    op_retrain_scores[subj_i] = op_retrain_score
  } else {
    op_retrain_scores[subj_i] = NA
  }
  op_retrained[subj_i] = retrained
  inverse_train_scores[subj_i] = inverse_train_score
  generator_train_scores[subj_i] = generator_train_score
  op_test_scores[subj_i] = op_test_score
  inverse_test_scores[subj_i] = inverse_test_score
  generator_test_scores[subj_i] = generator_test_score
  generator_tf_n_scores[subj_i] = generator_tf_n_score
  generator_asn_n_scores[subj_i] = generator_asn_n_score
}

polygon_scores = data.frame(condition=rep("polygon",length(polygon_data)),op_train_score=op_train_scores,op_retrained=op_retrained,op_retrain_scores=op_retrain_scores,inverse_train_score=inverse_train_scores,generator_train_score=generator_train_scores,op_test_score=op_test_scores,inverse_test_score=inverse_test_scores,generator_test_score=generator_test_scores,generator_tf_n_score=generator_tf_n_scores,generator_asn_n_score=generator_asn_n_scores)
```

Modular
```{r}
op_train_scores = vector()
op_retrain_scores = vector()
op_retrained = vector()
inverse_train_scores = vector()
generator_train_scores = vector()
op_test_scores = vector()
op_retested = vector()
inverse_test_scores = vector()
generator_test_scores = vector()

generator_tf_n_scores = vector() #True/False generator questions
generator_asn_n_scores = vector() #Always/Sometimes/Never generator questions

for (subj_i in 1:length(modular_data)){
  offset = 0
  retrained = FALSE

  if (gsub(" ","",modular_data[[subj_i]][[22]]$trial_type) != "instructions") { #Check whether subject had to do second operation training round, if yes, add offset, etc.
    offset = 20
    retrained = TRUE
  }

  #Training:
  #Operation
  num_train_probs = 10
   
  op_train_score = 0
  for (prob_i in seq(2,20,2)) { #Every other "trial" is a feedback screen
    if (modular_data[[subj_i]][[prob_i]]$response == modular_data[[subj_i]][[prob_i]]$correct_response) {
      op_train_score = op_train_score + 1
    }
  }
  op_train_score = 100*op_train_score/num_train_probs
  
  if (retrained) {
    op_retrain_score = 0
    for (prob_i in seq(22,40,2)) { #Every other "trial" is a feedback screen
      if (modular_data[[subj_i]][[prob_i]]$response == modular_data[[subj_i]][[prob_i]]$correct_response) {
        op_retrain_score = op_retrain_score + 1
      }
    }
    op_retrain_score = 100*op_retrain_score/num_train_probs
  }
  
  #Inverses
  inverse_train_score = 0
  for (prob_i in seq(24+offset,32+offset,2)) { #Every other "trial" is a feedback screen
    if (modular_data[[subj_i]][[prob_i]]$response == modular_data[[subj_i]][[prob_i]]$correct_response) {
      inverse_train_score = inverse_train_score + 1
    }
  }
  inverse_train_score = 100*inverse_train_score/5
  
  #Generators
  generator_train_score = 0
  for (prob_i in seq(36+offset,42+offset,2)) { #Every other "trial" is a feedback screen
    if (modular_data[[subj_i]][[prob_i]]$response == modular_data[[subj_i]][[prob_i]]$correct_response) {
      generator_train_score = generator_train_score + 1
    }
  }
  generator_train_score = 100*generator_train_score/4
  
  #Testing:
  #Operation

  modular_data[[subj_i]][[52+offset]]$correct_response = "5" #Left blank because of explain answer
  modular_data[[subj_i]][[53+offset]]$correct_response = "3" #Left blank because of explain answer
  
  op_test_score = 0
  for (prob_i in seq(47+offset,53+offset,1)) {
    if (substr(modular_data[[subj_i]][[prob_i]]$response,1,1) == modular_data[[subj_i]][[prob_i]]$correct_response) { #Substr is to deal with appended explanations.
      op_test_score = op_test_score + 1
    }
  }
  op_test_score = 100*op_test_score/7
  
  #Inverses
  modular_data[[subj_i]][[57+offset]]$correct_response = "6" #Left blank because of explain answer
    
  inverse_test_score = 0
  for (prob_i in seq(55+offset,56+offset,1)) {
    if (substr(modular_data[[subj_i]][[prob_i]]$response,1,1) == modular_data[[subj_i]][[prob_i]]$correct_response) {
      inverse_test_score = inverse_test_score + 1
    }
  }
  inverse_test_score = 100*inverse_test_score/2
  
  #Generators
  generator_test_score = 0
  #for (prob_i in seq(36+offset,42+offset,2)) { #Every other "trial" is a feedback screen
  #  if (modular_data[[subj_i]][[prob_i]]$response == modular_data[[subj_i]][[prob_i]]$correct_response) {
  #    generator_test_score = generator_test_score + 1
  #  }
  #}
  #generator_test_score = 100*generator_test_score/4  
  
  #Generic testing  
  generator_tf_n_score = 0
  for (prob_i in seq(66+offset,68+offset,1)) { #Every other "trial" is a feedback screen
   if (modular_data[[subj_i]][[prob_i]]$response == modular_data[[subj_i]][[prob_i]]$correct_response) {
     generator_tf_n_score = generator_tf_n_score + 1
   }
  }
  generator_tf_n_score = 100*generator_tf_n_score/3    
  
  generator_asn_n_score = 0
  for (prob_i in seq(70+offset,71+offset,1)) { #Every other "trial" is a feedback screen
   if (modular_data[[subj_i]][[prob_i]]$response == modular_data[[subj_i]][[prob_i]]$correct_response) {
     generator_asn_n_score = generator_asn_n_score + 1
   }
  }
  generator_asn_n_score = 100*generator_asn_n_score/2    
  
  #Add this subject's data to lists used to build frame
  op_train_scores[subj_i] = op_train_score
  if (retrained) {
    op_retrain_scores[subj_i] = op_retrain_score
  } else {
    op_retrain_scores[subj_i] = NA
  }
  op_retrained[subj_i] = retrained
  inverse_train_scores[subj_i] = inverse_train_score
  generator_train_scores[subj_i] = generator_train_score
  op_test_scores[subj_i] = op_test_score
  inverse_test_scores[subj_i] = inverse_test_score
  generator_test_scores[subj_i] = generator_test_score
  generator_tf_n_scores[subj_i] = generator_tf_n_score
  generator_asn_n_scores[subj_i] = generator_asn_n_score
}

modular_scores = data.frame(condition=rep("modular",length(modular_data)),op_train_score=op_train_scores,op_retrained=op_retrained,op_retrain_scores=op_retrain_scores,inverse_train_score=inverse_train_scores,generator_train_score=generator_train_scores,op_test_score=op_test_scores,inverse_test_score=inverse_test_scores,generator_test_score=generator_test_scores,generator_tf_n_score=generator_tf_n_scores,generator_asn_n_score=generator_asn_n_scores)

```

Polygon Prompt:
```{r}
op_train_scores = vector()
op_retrain_scores = vector()
op_retrained = vector()
inverse_train_scores = vector()
generator_train_scores = vector()
op_test_scores = vector()
op_retested = vector()
inverse_test_scores = vector()
generator_test_scores = vector()

generator_tf_n_scores = vector() #True/False generator questions
generator_asn_n_scores = vector() #Always/Sometimes/Never generator questions

for (subj_i in 1:length(polygon_prompt_data)){
  offset = 0
  retrained = FALSE

  if (gsub(" ","",polygon_prompt_data[[subj_i]][[22]]$trial_type) != "polygon-arrow-instructions") { #Check whether subject had to do second operation training round, if yes, add offset, etc.
    offset = 20
    retrained = TRUE
  }
  #Training:
  #Operation
  num_train_probs = 10
   
  op_train_score = 0
  for (prob_i in seq(2,20,2)) { #Every other "trial" is a feedback screen
    if (polygon_prompt_data[[subj_i]][[prob_i]]$response == polygon_prompt_data[[subj_i]][[prob_i]]$correct_response) {
      op_train_score = op_train_score + 1
    }
  }
  op_train_score = 100*op_train_score/num_train_probs
  
  if (retrained) {
    op_retrain_score = 0
    for (prob_i in seq(22,40,2)) { #Every other "trial" is a feedback screen
      if (polygon_prompt_data[[subj_i]][[prob_i]]$response == polygon_prompt_data[[subj_i]][[prob_i]]$correct_response) {
        op_retrain_score = op_retrain_score + 1
      }
    }
    op_retrain_score = 100*op_retrain_score/num_train_probs
  }
  
  #Inverses
  inverse_train_score = 0
  for (prob_i in seq(24+offset,32+offset,2)) { #Every other "trial" is a feedback screen
    if (polygon_prompt_data[[subj_i]][[prob_i]]$response == polygon_prompt_data[[subj_i]][[prob_i]]$correct_response) {
      inverse_train_score = inverse_train_score + 1
    }
  }
  inverse_train_score = 100*inverse_train_score/5
  
  offset = offset+1 #Inverse prompt
  
  #Generators
  generator_train_score = 0
  for (prob_i in seq(36+offset,42+offset,2)) { #Every other "trial" is a feedback screen
    if (polygon_prompt_data[[subj_i]][[prob_i]]$response == polygon_prompt_data[[subj_i]][[prob_i]]$correct_response) {
      generator_train_score = generator_train_score + 1
    }
  }
  generator_train_score = 100*generator_train_score/4
  
  offset = offset + 1 #generator prompt
  
  #Testing:
  #Operation

  polygon_prompt_data[[subj_i]][[52+offset]]$correct_response = "5" #Left blank because of explain answer
  polygon_prompt_data[[subj_i]][[53+offset]]$correct_response = "3" #Left blank because of explain answer
  
  op_test_score = 0
  for (prob_i in seq(47+offset,53+offset,1)) {
    if (substr(polygon_prompt_data[[subj_i]][[prob_i]]$response,1,1) == polygon_prompt_data[[subj_i]][[prob_i]]$correct_response) { #Substr is to deal with appended explanations.
      op_test_score = op_test_score + 1
    }
  }
  op_test_score = 100*op_test_score/7
  
  #Inverses
  polygon_prompt_data[[subj_i]][[57+offset]]$correct_response = "6" #Left blank because of explain answer
    
  inverse_test_score = 0
  for (prob_i in seq(55+offset,56+offset,1)) {
    if (substr(polygon_prompt_data[[subj_i]][[prob_i]]$response,1,1) == polygon_prompt_data[[subj_i]][[prob_i]]$correct_response) {
      inverse_test_score = inverse_test_score + 1
    }
  }
  inverse_test_score = 100*inverse_test_score/2
  
  #Generators
  generator_test_score = 0
  #for (prob_i in seq(36+offset,42+offset,2)) { #Every other "trial" is a feedback screen
  #  if (polygon_prompt_data[[subj_i]][[prob_i]]$response == polygon_prompt_data[[subj_i]][[prob_i]]$correct_response) {
  #    generator_test_score = generator_test_score + 1
  #  }
  #}
  #generator_test_score = 100*generator_test_score/4  

  #Generic testing  
  generator_tf_n_score = 0
  for (prob_i in seq(66+offset,68+offset,1)) { #Every other "trial" is a feedback screen
   if (polygon_prompt_data[[subj_i]][[prob_i]]$response == polygon_prompt_data[[subj_i]][[prob_i]]$correct_response) {
     generator_tf_n_score = generator_tf_n_score + 1
   }
  }
  generator_tf_n_score = 100*generator_tf_n_score/3    
  
  generator_asn_n_score = 0
  for (prob_i in seq(70+offset,71+offset,1)) { #Every other "trial" is a feedback screen
   if (polygon_prompt_data[[subj_i]][[prob_i]]$response == polygon_prompt_data[[subj_i]][[prob_i]]$correct_response) {
     generator_asn_n_score = generator_asn_n_score + 1
   }
  }
  generator_asn_n_score = 100*generator_asn_n_score/2    
  
  #Add this subject's data to lists used to build frame
  op_train_scores[subj_i] = op_train_score
  if (retrained) {
    op_retrain_scores[subj_i] = op_retrain_score
  } else {
    op_retrain_scores[subj_i] = NA
  }
  op_retrained[subj_i] = retrained
  inverse_train_scores[subj_i] = inverse_train_score
  generator_train_scores[subj_i] = generator_train_score
  op_test_scores[subj_i] = op_test_score
  inverse_test_scores[subj_i] = inverse_test_score
  generator_test_scores[subj_i] = generator_test_score
  generator_tf_n_scores[subj_i] = generator_tf_n_score
  generator_asn_n_scores[subj_i] = generator_asn_n_score
}

polygon_prompt_scores = data.frame(condition=rep("polygon_prompt",length(polygon_prompt_data)),op_train_score=op_train_scores,op_retrained=op_retrained,op_retrain_scores=op_retrain_scores,inverse_train_score=inverse_train_scores,generator_train_score=generator_train_scores,op_test_score=op_test_scores,inverse_test_score=inverse_test_scores,generator_test_score=generator_test_scores,generator_tf_n_score=generator_tf_n_scores,generator_asn_n_score=generator_asn_n_scores)
```


Modular Prompt
```{r}
op_train_scores = vector()
op_retrain_scores = vector()
op_retrained = vector()
inverse_train_scores = vector()
generator_train_scores = vector()
op_test_scores = vector()
op_retested = vector()
inverse_test_scores = vector()
generator_test_scores = vector()

generator_tf_n_scores = vector() #True/False generator questions
generator_asn_n_scores = vector() #Always/Sometimes/Never generator questions

for (subj_i in 1:length(modular_prompt_data)){
  offset = 0
  retrained = FALSE

  if (gsub(" ","",modular_prompt_data[[subj_i]][[22]]$trial_type) != "instructions") { #Check whether subject had to do second operation training round, if yes, add offset, etc.
    offset = 20
    retrained = TRUE
  }

  #Training:
  #Operation
  num_train_probs = 10
   
  op_train_score = 0
  for (prob_i in seq(2,20,2)) { #Every other "trial" is a feedback screen
    if (modular_prompt_data[[subj_i]][[prob_i]]$response == modular_prompt_data[[subj_i]][[prob_i]]$correct_response) {
      op_train_score = op_train_score + 1
    }
  }
  op_train_score = 100*op_train_score/num_train_probs
  
  if (retrained) {
    op_retrain_score = 0
    for (prob_i in seq(22,40,2)) { #Every other "trial" is a feedback screen
      if (modular_prompt_data[[subj_i]][[prob_i]]$response == modular_prompt_data[[subj_i]][[prob_i]]$correct_response) {
        op_retrain_score = op_retrain_score + 1
      }
    }
    op_retrain_score = 100*op_retrain_score/num_train_probs
  }
  
  #Inverses
  inverse_train_score = 0
  for (prob_i in seq(24+offset,32+offset,2)) { #Every other "trial" is a feedback screen
    if (modular_prompt_data[[subj_i]][[prob_i]]$response == modular_prompt_data[[subj_i]][[prob_i]]$correct_response) {
      inverse_train_score = inverse_train_score + 1
    }
  }
  inverse_train_score = 100*inverse_train_score/5
  
  offset = offset + 1 #inverse prompt
  
  #Generators
  generator_train_score = 0
  for (prob_i in seq(36+offset,42+offset,2)) { #Every other "trial" is a feedback screen
    if (modular_prompt_data[[subj_i]][[prob_i]]$response == modular_prompt_data[[subj_i]][[prob_i]]$correct_response) {
      generator_train_score = generator_train_score + 1
    }
  }
  generator_train_score = 100*generator_train_score/4
  
  offset = offset + 1 #generator prompt
  #Testing:
  #Operation

  modular_prompt_data[[subj_i]][[52+offset]]$correct_response = "5" #Left blank because of explain answer
  modular_prompt_data[[subj_i]][[53+offset]]$correct_response = "3" #Left blank because of explain answer
  
  op_test_score = 0
  for (prob_i in seq(47+offset,53+offset,1)) {
    if (substr(modular_prompt_data[[subj_i]][[prob_i]]$response,1,1) == modular_prompt_data[[subj_i]][[prob_i]]$correct_response) { #Substr is to deal with appended explanations.
      op_test_score = op_test_score + 1
    }
  }
  op_test_score = 100*op_test_score/7
  
  #Inverses
  modular_prompt_data[[subj_i]][[57+offset]]$correct_response = "6" #Left blank because of explain answer
    
  inverse_test_score = 0
  for (prob_i in seq(55+offset,56+offset,1)) {
    if (substr(modular_prompt_data[[subj_i]][[prob_i]]$response,1,1) == modular_prompt_data[[subj_i]][[prob_i]]$correct_response) {
      inverse_test_score = inverse_test_score + 1
    }
  }
  inverse_test_score = 100*inverse_test_score/2
  
  #Generators
  generator_test_score = 0
  #for (prob_i in seq(36+offset,42+offset,2)) { #Every other "trial" is a feedback screen
  #  if (modular_prompt_data[[subj_i]][[prob_i]]$response == modular_prompt_data[[subj_i]][[prob_i]]$correct_response) {
  #    generator_test_score = generator_test_score + 1
  #  }
  #}
  #generator_test_score = 100*generator_test_score/4  
  
  #Generic testing  
  generator_tf_n_score = 0
  for (prob_i in seq(66+offset,68+offset,1)) { #Every other "trial" is a feedback screen
   if (modular_prompt_data[[subj_i]][[prob_i]]$response == modular_prompt_data[[subj_i]][[prob_i]]$correct_response) {
     generator_tf_n_score = generator_tf_n_score + 1
   }
  }
  generator_tf_n_score = 100*generator_tf_n_score/3    
  
  generator_asn_n_score = 0
  for (prob_i in seq(70+offset,71+offset,1)) { #Every other "trial" is a feedback screen
   if (modular_prompt_data[[subj_i]][[prob_i]]$response == modular_prompt_data[[subj_i]][[prob_i]]$correct_response) {
     generator_asn_n_score = generator_asn_n_score + 1
   }
  }
  generator_asn_n_score = 100*generator_asn_n_score/2    
  
  #Add this subject's data to lists used to build frame
  op_train_scores[subj_i] = op_train_score
  if (retrained) {
    op_retrain_scores[subj_i] = op_retrain_score
  } else {
    op_retrain_scores[subj_i] = NA
  }
  op_retrained[subj_i] = retrained
  inverse_train_scores[subj_i] = inverse_train_score
  generator_train_scores[subj_i] = generator_train_score
  op_test_scores[subj_i] = op_test_score
  inverse_test_scores[subj_i] = inverse_test_score
  generator_test_scores[subj_i] = generator_test_score
  generator_tf_n_scores[subj_i] = generator_tf_n_score
  generator_asn_n_scores[subj_i] = generator_asn_n_score
}

modular_prompt_scores = data.frame(condition=rep("modular_prompt",length(modular_prompt_data)),op_train_score=op_train_scores,op_retrained=op_retrained,op_retrain_scores=op_retrain_scores,inverse_train_score=inverse_train_scores,generator_train_score=generator_train_scores,op_test_score=op_test_scores,inverse_test_score=inverse_test_scores,generator_test_score=generator_test_scores,generator_tf_n_score=generator_tf_n_scores,generator_asn_n_score=generator_asn_n_scores)

```


#RT
--------------------------------
Full averaged RT data (including all problem types):
```{r}
av_RT = vector()
for (subj_i in 1:length(polygon_data)) {
  subj_RT = 0
  question_count = 0
  for (prob_i in 1:length(polygon_data[[subj_i]])) {
    if (grepl("question",polygon_data[[subj_i]][[prob_i]]$trial_type)) {
      subj_RT = subj_RT + polygon_data[[subj_i]][[prob_i]]$rt
      question_count = question_count + 1
    }
  }
  av_RT[subj_i] = subj_RT/question_count
}
polygon_scores$av_RT = av_RT

av_RT = vector()
for (subj_i in 1:length(modular_data)) {
  subj_RT = 0
  question_count = 0
  for (prob_i in 1:length(modular_data[[subj_i]])) {
    if (grepl("question",modular_data[[subj_i]][[prob_i]]$trial_type)) {
      subj_RT = subj_RT + modular_data[[subj_i]][[prob_i]]$rt
      question_count = question_count + 1
    }
  }
  av_RT[subj_i] = subj_RT/question_count
}
modular_scores$av_RT = av_RT

av_RT = vector()
for (subj_i in 1:length(polygon_prompt_data)) {
  subj_RT = 0
  question_count = 0
  for (prob_i in 1:length(polygon_prompt_data[[subj_i]])) {
    if (grepl("question",polygon_prompt_data[[subj_i]][[prob_i]]$trial_type)) {
      subj_RT = subj_RT + polygon_prompt_data[[subj_i]][[prob_i]]$rt
      question_count = question_count + 1
    }
  }
  av_RT[subj_i] = subj_RT/question_count
}
polygon_prompt_scores$av_RT = av_RT

av_RT = vector()
for (subj_i in 1:length(modular_prompt_data)) {
  subj_RT = 0
  question_count = 0
  for (prob_i in 1:length(modular_prompt_data[[subj_i]])) {
    if (grepl("question",modular_prompt_data[[subj_i]][[prob_i]]$trial_type)) {
      subj_RT = subj_RT + modular_prompt_data[[subj_i]][[prob_i]]$rt
      question_count = question_count + 1
    }
  }
  av_RT[subj_i] = subj_RT/question_count
}
modular_prompt_scores$av_RT = av_RT

```


```{r}
total_messy_data = rbind(modular_scores,modular_prompt_scores,polygon_scores,polygon_prompt_scores)
```

Analysis
----------------------------
simple plots of percent correct by condition, using only data that is unscored
```{r}
to_plot = c(2,7,5,8,6,10,11,12)
column_names = colnames(total_messy_data)

for (i in 1:length(to_plot)) {
  print(ggplot(total_messy_data,aes(condition,total_messy_data[,to_plot[i]],fill=condition)) +
    geom_boxplot() +
    theme_bw() +
    labs(x="Condition",y=column_names[to_plot[i]]))
}

```

Statistics
---------------------
##Operation
train
```{r}
mod = lmer(score_strict ~ polygon  + (1|subject), data=complete_data[grepl("Remember,toperform",gsub(" ","",complete_data$question)),]) #Collapsing across prompt/non-prompt conditions because they are equivalent up to this point
summary(mod)

```

test
```{r}
mod = lmer(score_strict ~ polygon  + (1|subject), data=complete_data[!(grepl("identity",gsub(" ","",complete_data$question)) | grepl("inverse",gsub(" ","",complete_data$question)) | grepl("generator",gsub(" ","",complete_data$question))) & (grepl("nonagon",gsub(" ","",complete_data$question)) | grepl("+<sub>9",gsub(" ","",complete_data$question)) ),]) #Collapsing across prompt/non-prompt conditions because they are equivalent up to this point
summary(mod)

```

The models do not differ significantly for learning the operation.

##Inverses
Inverse train score model:
```{r}


aggregated_data = complete_data[grepl("Remember,theinverse",gsub(" ","",complete_data$question)),] %>% mutate(correct_response=gsub(" ","",correct_response)) %>% select(score_strict,condition,polygon,prompt,correct_response,subject) %>% spread(correct_response,score_strict) %>% mutate(score = `0`+`2`+`3`+`4`+`5`)
  
ggplot(aggregated_data,aes(condition,score,fill=condition)) +
    geom_boxplot() +
    theme_bw() +
    labs(x="Condition",y="Inverse Train Accuracy")

mod = lmer(score_strict ~ polygon  + (1|subject), data=complete_data[grepl("Remember,theinverse",gsub(" ","",complete_data$question)),]) #Collapsing across prompt/non-prompt conditions because they are equivalent up to this point
summary(mod)

```

Is this effect driven by performance on the "inverse of 0" question? 
```{r}
ggplot(aggregated_data,aes(condition,`0`,fill=condition)) +
    geom_boxplot() +
    theme_bw() +
    labs(x="Condition",y="Inverse of 0 Train Accuracy")

mod0 = lm(score_strict ~ polygon, data=complete_data[grepl("Whatistheinverseof0",gsub(" ","",complete_data$question)),]) #Test only the results on the inverse of 0 question
summary(mod0)

aggregated_data = aggregated_data %>% mutate(score_non_zero = score - `0`)

ggplot(aggregated_data,aes(condition,score_non_zero,fill=condition)) +
    geom_boxplot() +
    theme_bw() +
    labs(x="Condition",y="Inverse of Non-zero Elements Train Accuracy")


modnz = lmer(score_strict ~ polygon  + (1|subject), data=complete_data[grepl("Remember,theinverse",gsub(" ","",complete_data$question)) & !grepl("Whatistheinverseof0",gsub(" ","",complete_data$question)) ,]) #Test results on the non-zero questions
summary(modnz)
```

The polygon group performed significantly better on the "inverse of 0" question, but the groups were not significantly different on the other two conditions.

Inverse test score model:
```{r}


aggregated_data = complete_data[grepl("Whatistheinverse",gsub(" ","",complete_data$question)) & !grepl("Remember,theinverse",gsub(" ","",complete_data$question)),] %>% mutate(correct_response=gsub(" ","",correct_response)) %>% select(score_strict,condition,polygon,prompt,correct_response,subject) %>% spread(correct_response,score_strict) %>% mutate(score = `4`+`7`)
  
ggplot(aggregated_data,aes(condition,score,fill=condition)) +
    geom_boxplot() +
    theme_bw() +
    labs(x="Condition",y="Inverse Test Accuracy")

mod = lmer(score_strict ~ polygon*prompt  + (1|subject), data=complete_data[grepl("Whatistheinverse",gsub(" ","",complete_data$question)) & !grepl("Remember,theinverse",gsub(" ","",complete_data$question)) ,])
summary(mod)

mod0 = lmer(score_strict ~ polygon  + (1|subject), data=complete_data[grepl("Whatistheinverse",gsub(" ","",complete_data$question)) & !grepl("Remember,theinverse",gsub(" ","",complete_data$question)) ,])
summary(mod0)

anova(mod0,mod)
```

The difference went in the opposite direction in the test case, where we unfortunately did not ask about the inverse of 0 when n=9.
  
Inverse of 1, inverse of x questions
```{r}
ggplot(complete_data[inverse_formula_scores$row.names,],aes(condition,score_strict,fill=condition)) +
    geom_boxplot() +
    theme_bw() +
    labs(x="Condition",y="Accuracy")

# aggregated_data = complete_data[inverse_formula_scores$row.names,] %>% mutate(x_question = ifelse(grepl("x",correct_response),"x","one")) %>% select(score_strict,polygon,prompt,x_question,subject) %>% spread(x_question,score_strict) %>% mutate(score_strict = (one + x)/2)
#mod = lm(score_strict ~ polygon * prompt, data=aggregated_data)
#summary(mod)

#Model -- Just a nicer way of  doing the above model
mod_strict = lmer(score_strict ~ polygon * prompt + (1|subject), data=complete_data[inverse_formula_scores$row.names,])
summary(mod_strict)
mod_strict0.5 = lmer(score_strict ~ polygon + prompt + (1|subject), data=complete_data[inverse_formula_scores$row.names,])
summary(mod_strict0.5)
mod_strict0 = lmer(score_strict ~ polygon +(1|subject), data=complete_data[inverse_formula_scores$row.names,])
summary(mod_strict0)
anova(mod_strict0,mod_strict0.5,mod_strict)
```

Does it make a difference using the non-strict score? (Including half credit for answers that made small errors like flipping a sign, "x-n" instead of "n-x", etc.)
```{r}
ggplot(complete_data[inverse_formula_scores$row.names,],aes(condition,score,fill=condition)) +
    geom_boxplot() +
    theme_bw() +
    labs(x="Condition",y="Score w/ Partial Credit")

mod_partial_credit = lmer(score ~ polygon * prompt + (1|subject), data=complete_data[inverse_formula_scores$row.names,])
summary(mod_partial_credit)
```

##Generators

Training (Order 6):
```{r}
ggplot(complete_data[grepl("generatorunder",gsub(" ","",complete_data$question)) & (grepl("hexagon",gsub(" ","",complete_data$question)) | grepl("+<sub>6",gsub(" ","",complete_data$question)) ),],aes(condition,score_strict,fill=condition)) +
    geom_boxplot() +
    theme_bw() +
    labs(x="Condition",y="Generator Training Accuracy")

mod = lmer(score_strict ~ polygon * prompt + (1|subject), data=complete_data[grepl("generatorunder",gsub(" ","",complete_data$question)) & (grepl("hexagon",gsub(" ","",complete_data$question)) | grepl("+<sub>9",gsub(" ","",complete_data$question)) ),])
summary(mod)
mod0.5 = lmer(score_strict ~ polygon + prompt + (1|subject), data=complete_data[grepl("generatorunder",gsub(" ","",complete_data$question)) & (grepl("hexagon",gsub(" ","",complete_data$question)) | grepl("+<sub>9",gsub(" ","",complete_data$question)) ),])
summary(mod0.5)
mod0 = lmer(score_strict ~ polygon + (1|subject), data=complete_data[grepl("generatorunder",gsub(" ","",complete_data$question)) & (grepl("hexagon",gsub(" ","",complete_data$question)) | grepl("+<sub>9",gsub(" ","",complete_data$question)) ),])
summary(mod0)
anova(mod0,mod0.5,mod)
```


Testing (order 9):
```{r}
ggplot(complete_data[grepl("generatorunder",gsub(" ","",complete_data$question)) & (grepl("nonagon",gsub(" ","",complete_data$question)) | grepl("+<sub>9",gsub(" ","",complete_data$question)) ),],aes(condition,score_strict,fill=condition)) +
    geom_boxplot() +
    theme_bw() +
    labs(x="Condition",y="Generators order 9 Test Accuracy")

mod = lmer(score_strict ~ polygon * prompt + (1|subject), data=complete_data[grepl("generatorunder",gsub(" ","",complete_data$question)) & (grepl("nonagon",gsub(" ","",complete_data$question)) | grepl("+<sub>9",gsub(" ","",complete_data$question)) ),])
summary(mod)
```

More info: including the number as possible effect, exploring different models with and without prompt and prompt x polygon interaction
```{r}
temp_data = complete_data[grepl("generatorunder",gsub(" ","",complete_data$question)) & (grepl("nonagon",gsub(" ","",complete_data$question)) | grepl("+<sub>9",gsub(" ","",complete_data$question)) ),]
temp_data = temp_data %>% mutate(number=ifelse(grepl("2",temp_data$question),2,ifelse(grepl("3",temp_data$question),3,ifelse(grepl("5",temp_data$question),5,6)))) 
temp_data$number = factor(temp_data$number)
temp_data$subject = factor(temp_data$subject)


#Does the interactive model fit the data better than an additive model, or one with just the main effect of polygon group, and no prompt effect?
mod0 = glmer(score_strict ~ polygon + number+ (1|subject), data=temp_data,family=binomial)
mod1 = glmer(score_strict ~ polygon + prompt + number + (1|subject), data=temp_data,family=binomial)
mod2 = glmer(score_strict ~ polygon * prompt + number + (1|subject), data=temp_data,family=binomial)
anova(mod0,mod1,mod2)
#Could there be an interaction of number and group?
mod0.5 = glmer(score_strict ~ polygon * number+ (1|subject), data=temp_data,family=binomial)
anova(mod0,mod0.5)

summary(mod0)

#Would it be better to treat number as a random effect?
mod0a = glmer(score_strict ~ polygon + (1|number)+ (1|subject), data=temp_data,family=binomial)
AIC(mod0a,mod0) #No

#Is it just whether the number generates rather than which number it is?
temp_data = temp_data %>% mutate(generator=ifelse(number==2 | number==5,TRUE,FALSE))
mod0b = glmer(score_strict ~ polygon + generator+(1|subject), data=temp_data,family=binomial)
AIC(mod0b,mod0) #Yes, why didn't I try that first

summary(mod0b)


```

It appears that there is a significant positive effect of polygon condition on ability to correctly test whether something is a generator, and a highly significant negative effect of the element actually being a generator. Subjects show a strong bias toward saying that an element is not a generator when it is.

Order n T/F:
```{r}
ggplot(complete_data[grepl("Trueorfalse",gsub(" ","",complete_data$question)),],aes(condition,score_strict,fill=condition)) +
    geom_boxplot() +
    theme_bw() +
    labs(x="Condition",y="Generators order n T/F Accuracy")

mod = lmer(score_strict ~ polygon * prompt + (1|subject), data=complete_data[grepl("Trueorfalse",gsub(" ","",complete_data$question)),])
mod0.5 = lmer(score_strict ~ polygon + prompt + (1|subject), data=complete_data[grepl("Trueorfalse",gsub(" ","",complete_data$question)),])
mod0 = lmer(score_strict ~ polygon + (1|subject), data=complete_data[grepl("Trueorfalse",gsub(" ","",complete_data$question)),])
anova(mod0,mod0.5,mod)
summary(mod0)
```

The polygon group was significantly worse at the order n T/F questions.

Order n A/S/N:
```{r}
ggplot(complete_data[grepl("always,sometimes,ornever",gsub(" ","",complete_data$question)),],aes(condition,score_strict,fill=condition)) +
    geom_boxplot() +
    theme_bw() +
    labs(x="Condition",y="Generators order n A/S/N Accuracy")

mod = lmer(score_strict ~ polygon * prompt + (1|subject), data=complete_data[grepl("always,sometimes,ornever",gsub(" ","",complete_data$question)),])
summary(mod)
mod0.5 = lmer(score_strict ~ polygon + prompt + (1|subject), data=complete_data[grepl("always,sometimes,ornever",gsub(" ","",complete_data$question)),])
summary(mod0.5)
mod0 = lmer(score_strict ~ polygon + (1|subject), data=complete_data[grepl("always,sometimes,ornever",gsub(" ","",complete_data$question)),])
summary(mod0)
```


##RT

```{r}
complete_data$rt = complete_data$rt/1000 #convert from ms to s
```


```{r}
rt_mod = lmer(rt ~ polygon + (1|subject),data=complete_data)
summary(rt_mod)
```

No significant overall difference, but this is averaged across all questions, so there may be a larger effect in some problem types. Try just the operation training:

```{r}
rt_mod = lmer(rt ~ polygon + (1|subject),data=complete_data[grepl("Remember,toperform",gsub(" ","",complete_data$question)),])
summary(rt_mod)
```

Not significant

##Question by question

```{r}
polygon_question = vector()
modular_question = vector()
polygon_question_aggregate_scores = vector()
modular_question_aggregate_scores = vector()
for (subj_i in 1:100) {
  this_subj_data = complete_data[complete_data$subject == subj_i,]
  this_subj_polygon = this_subj_data[1,]$polygon
  index = 1
  prob_i = 1
  offset = 0
  while (prob_i <= length(this_subj_data$question)) {
    if (prob_i==(11+offset) && grepl("Remember,toperform",gsub(" ","",this_subj_data[prob_i,]$question)))   { #If subject had to repeat training
      prob_i = prob_i+10      
      offset = offset + 10
    } 
    if (prob_i == 16+offset && grepl("prompt",this_subj_data[prob_i,]$condition)) {
      prob_i = prob_i+1
      offset = offset + 1
    }
    if (prob_i == 20+offset && grepl("prompt",this_subj_data[prob_i,]$condition)) {
      prob_i = prob_i+1
      offset = offset + 1
    }
    if (prob_i == 58+offset){ #Skip background questions
      break
    }
    
    if (this_subj_polygon) {
      this_problem_score = this_subj_data[prob_i,]$score_strict
      if (is.na(polygon_question_aggregate_scores[index])) {
        polygon_question_aggregate_scores[index] = this_problem_score 
        polygon_question[index] = this_subj_data[prob_i,]$question
      }
      else {
        polygon_question_aggregate_scores[index] = polygon_question_aggregate_scores[index] + this_problem_score 
      }
    } 
    else {
      this_problem_score = this_subj_data[prob_i,]$score_strict
      if (is.na(modular_question_aggregate_scores[index])) {
        modular_question_aggregate_scores[index] = this_problem_score 
        modular_question[index] = this_subj_data[prob_i,]$question
      }
      else {
        modular_question_aggregate_scores[index] = modular_question_aggregate_scores[index] + this_problem_score 
      }
      
    }
    
    prob_i = prob_i+1
    index = index + 1
  }
}
```

```{r}
aggregate_score_data = data.frame(condition=c(rep('polygon',length(polygon_question_aggregate_scores)),rep('modular',length(modular_question_aggregate_scores))),score=c(polygon_question_aggregate_scores,modular_question_aggregate_scores),question_index=rep(1:length(polygon_question_aggregate_scores),2))

aggregate_score_data = aggregate_score_data %>% mutate(percent_correct = score/50)

ggplot(data=aggregate_score_data,aes(question_index,percent_correct,fill=condition)) +
  geom_bar(stat='identity',position='dodge',width=0.5) +
  theme_bw()
```

