---
title: "fyp_3_analysis_unified"
output: html_document
---
```{r}
library(rjson)
library(ggplot2)
library(tidyr)
library(dplyr)
library(lme4)
library(lmerTest)
library(boot)
library(stringr)
library(gtools) #smartbind
```


#Read files:
```{r}
data_location = "../data/fyp_3_pilot_data/" 
files = list.files(path = data_location,pattern="data_subject_.*.json")
modular_data = vector()
polygon_data = vector()
hybrid_data = vector()
#data frame building
subject = vector()
prompt = vector()
explain = vector()
explanation = vector()
correct_response = vector()
rt = vector()
response = vector()
condition = vector()
trial_index = vector()
score = vector()

j = 1
for (i in 1:length(files)) {
  path = paste(data_location,files[i],sep="")
  print(i)
  print(path)
  c = file(path, "r")
  l = readLines(c, -1L)
  close(c)
  these_data = lapply(X=l, fromJSON)
  if (these_data[1][[1]][[1]]$trial_type == "instructions") {
      this_condition = "modular"
      modular_data[length(modular_data) + 1] = these_data[1]
  } else {
    if (grepl("subtract",gsub(" ","",these_data[1][[1]][[1]]$instructions))) { 
        this_condition = "hybrid"
        hybrid_data[length(hybrid_data) + 1] = these_data[1]
    }
    else {
       this_condition = "polygon"
       polygon_data[length(polygon_data) + 1] = these_data[1]
    }
  }
  
  for (trial_i in 1:length(these_data[1][[1]])) {
    if(grepl("question",gsub(" ","",these_data[1][[1]][[trial_i]]$trial_type))) {
      subject[j] = i
      condition[j] = this_condition
      prompt[j] = these_data[1][[1]][[trial_i]]$question
      correct_response[j] = these_data[1][[1]][[trial_i]]$correct_response
      explain[j] = these_data[1][[1]][[trial_i]]$explain
      if (is.null(these_data[1][[1]][[trial_i]]$explanation) | is.list(these_data[1][[1]][[trial_i]]$explanation)) { #is.list handles the unfortunate partial matching of explanation to explanation_history when explanation is null
        explanation[j] = NA
      } else {
        explanation[j] = these_data[1][[1]][[trial_i]]$explanation
      }
      
      if (is.null(these_data[1][[1]][[trial_i]]$response)) {
        response[j] = NA
      }
      else {
        response[j] = these_data[1][[1]][[trial_i]]$response
      }
      
      if (!is.na(response[j]) && response[j] == correct_response[j]) {
        score[j] = 1
      } else {
        score[j] = 0        
      }
      rt[j] = these_data[1][[1]][[trial_i]]$rt
      trial_index[j] = trial_i
      
      j = j+1
    }
  }
}
```

Write data for scoring
----------------------------

```{r}
#n-1,n-x
write.table(complete_data[grepl("formula",gsub(" ","",complete_data$question)),c(1,4,5,8,10)],paste(data_location,"inverse_formula_to_score.csv",sep=''),sep=",")

#Highest math class completed, 1 if algebra 2/trig/stats or higher, 0 else
write.table(complete_data[grepl('mathclass',gsub(' ','',complete_data$question)),c(1,4,5,8,10)],paste(data_location,"highest_math_class_to_score.csv",sep=''),sep=",")

#NOT YET SCORED for explanations
# #n=9 operation questions
# write.table(complete_data[(grepl("Whatis8",gsub(" ","",complete_data$question)) | grepl("Whatis4",gsub(" ","",complete_data$question)))& grepl("explaininwords",gsub(" ","",complete_data$question)) ,c(1,3,4,5,7)],paste(data_location,"N9_operation_to_score.csv",sep=''),sep=",")
# 
# #n=9 generator questions
# write.table(complete_data[grepl("generatorunder",gsub(" ","",complete_data$question)) & (grepl("nonagon",gsub(" ","",complete_data$question)) | grepl("+<sub>9",gsub(" ","",complete_data$question)) ),c(1,3,4,5,7)],paste(data_location,"N9_generator_to_score.csv",sep=''),sep=",")
# 
# #n=9 inverse with explanations
# write.table(complete_data[grepl("inverseof3",gsub(" ","",complete_data$question)) & (grepl("nonagon",gsub(" ","",complete_data$question)) | grepl("+<sub>9",gsub(" ","",complete_data$question)) ),c(1,4,5,7)],paste(data_location,"N9_inverse_to_score.csv",sep=''),sep=",")
# 
# #generator T/F and A/S/N with explanations
# write.table(complete_data[grepl("explaininwords",gsub(" ","",complete_data$question)) & (grepl("Trueorfalse",gsub(" ","",complete_data$question)) | grepl("always,sometimes,ornever",gsub(" ","",complete_data$question))),c(1,4,5,7)],paste(data_location,"TF_ASN_explained_to_score.csv",sep=''),sep=",")


```

data frame building
------------------------
```{r}
complete_data = data.frame(subject=factor(subject),condition=condition,question=prompt,correct_response=correct_response,response=response,rt=rt,explain=explain,explanation=explanation,trial_index=trial_index,score=score) 

#Insert scored data
inverse_formula_scores = read.csv(paste(data_location,"inverse_formula_scored.csv",sep=""))
complete_data[inverse_formula_scores$row.names,]$score = inverse_formula_scores$score

#Strict scoring -- Some questions have "partial credit" of 0.5 for almost correct answers
complete_data = complete_data %>% mutate(score_strict = floor(score)) %>% 
  mutate(polygon=grepl("polygon",condition)) #Factors of condition


```

Change dummy coding to compare hybrid and polygon to modular.
```{r}
contrasts(complete_data$condition) = cbind(c(0,0,1),c(1,0,0))
colnames(contrasts(complete_data$condition)) = c('polygon','hybrid')
contrasts(complete_data$condition) 
```

Subject Demographics
-----------------

```{r}
subject_data = complete_data %>% 
  filter(grepl('education',gsub(" ","",question)) | grepl('yourgender',gsub(" ","",question)) ) %>%
  mutate(demographic_type = ifelse(grepl('education',gsub(" ","",question)),'education','gender')) %>%
  select(subject,demographic_type,response,polygon) %>%
  mutate(response = gsub(' ','',response)) %>%
  spread(demographic_type,response) %>%
  mutate(education_high = ifelse(grepl('Bachelors',education),1,ifelse(grepl('Masters',education),1,ifelse(grepl('graduate',education),1,ifelse(grepl('Doctorate',education),1,0)))))

highest_math_classes =read.csv(paste(data_location,"highest_math_class_scored.csv",sep=""))
subject_data$math_high = highest_math_classes$math_high
```

Subject exclusion
----------------------
Exclude subjects who responded 4 or higher on familiarity with modular arithmetic or mathematical groups: they know too much

```{r}
complete_unfiltered_data = complete_data
subjects_to_exclude = unique(complete_data[grepl("Howfamiliarareyou",gsub(" ","",complete_data$question)) & (grepl("4",complete_data$response) | grepl("5",complete_data$response)),]$subject)

complete_data = complete_unfiltered_data %>% filter(!(subject %in% subjects_to_exclude))


```


Unified model - all 3 (Planned analysis)
---------------

```{r}
complete_data = complete_data %>% mutate(question_type = rep(NA,nrow(complete_data))) %>% inner_join(subject_data)

#Operation questions
complete_data[grepl("Remember,toperform",gsub(" ","",complete_data$question)),]$question_type = 'a_operation_6' #a is so it will appear at the beginning of models as reference level, to make life easier than manually altering the contrasts
complete_data[!(grepl("identity",gsub(" ","",complete_data$question)) | grepl("inverse",gsub(" ","",complete_data$question)) | grepl("generator",gsub(" ","",complete_data$question))) & (grepl("nonagon",gsub(" ","",complete_data$question)) | grepl("+<sub>9",gsub(" ","",complete_data$question)) ),]$question_type = 'operation_9'

#Inverse Questions -- Order 6
complete_data[grepl("Remember,theinverse",gsub(" ","",complete_data$question)),]$question_type = 'inverse_nonzero_6'
complete_data[grepl("Remember,theinverse",gsub(" ","",complete_data$question)) & complete_data$correct_response == '0',]$question_type = 'inverse_zero_6'
  
#Inverse Questions -- Order 9
complete_data[grepl("Whatistheinverse",gsub(" ","",complete_data$question)) & !grepl("Remember,theinverse",gsub(" ","",complete_data$question)),]$question_type = 'inverse_nonzero_9'
complete_data[grepl("Whatistheinverse",gsub(" ","",complete_data$question)) & !grepl("Remember,theinverse",gsub(" ","",complete_data$question)) & gsub(" ","",complete_data$correct_response) == '0',]$question_type = 'inverse_zero_9' 

#Inverse Questions -- order n
complete_data[inverse_formula_scores$row.names,]$question_type = 'inverse_formula_n'

#Generator Questions -- 6
complete_data[grepl("generatorunder",gsub(" ","",complete_data$question)) & (grepl("hexagon",gsub(" ","",complete_data$question)) | grepl("+<sub>6",gsub(" ","",complete_data$question)) ),]$question_type = 'generator_false_6'
complete_data[grepl("generatorunder",gsub(" ","",complete_data$question)) & (grepl("hexagon",gsub(" ","",complete_data$question)) | grepl("+<sub>6",gsub(" ","",complete_data$question)) ) & gsub(" ","",correct_response) == 'Yes',]$question_type = 'generator_true_6'

#Generator Questions -- 9
complete_data[grepl("generatorunder",gsub(" ","",complete_data$question)) & (grepl("nonagon",gsub(" ","",complete_data$question)) | grepl("+<sub>9",gsub(" ","",complete_data$question)) ),]$question_type = 'generator_false_9'
complete_data[grepl("generatorunder",gsub(" ","",complete_data$question)) & (grepl("nonagon",gsub(" ","",complete_data$question)) | grepl("+<sub>9",gsub(" ","",complete_data$question)) ) & (grepl('5',gsub(" ","",complete_data$question)) | grepl('2',gsub(" ","",complete_data$question))),]$question_type = 'generator_true_9'

#Generator T/F Questions -- n
complete_data[grepl("Trueorfalse",gsub(" ","",complete_data$question)),]$question_type = 'generator_TF_n'

#Generator A/S/N Questions -- n
complete_data[grepl("always,sometimes,ornever",gsub(" ","",complete_data$question)),]$question_type = 'generator_ASN_n'
```

```{r}
model_data = complete_data %>% filter(!is.na(question_type))
model_data$question_type = factor(model_data$question_type)
```

```{r}
model_data$condition = relevel(model_data$condition,ref='modular') #Because the previous doesn't seem to carry over
```

```{r}
tm = proc.time()
num_boot_samples = 10000
boot_polygon_subjects = unique(model_data[model_data$condition == 'polygon',]$subject)
boot_modular_subjects = unique(model_data[model_data$condition == 'modular',]$subject)
boot_hybrid_subjects = unique(model_data[model_data$condition == 'hybrid',]$subject)

#fencepost problem with coefficient storage
these_subjects = c(sample(boot_polygon_subjects,length(boot_polygon_subjects),replace=TRUE),sample(boot_modular_subjects,length(boot_modular_subjects),replace=TRUE),sample(boot_hybrid_subjects,length(boot_hybrid_subjects),replace=TRUE))
this_model_data = do.call(rbind,lapply(these_subjects,function(i) model_data[model_data$subject == i,]))
this_mod = glm(data=this_model_data, score_strict ~ question_type*condition+math_high)
bootstrapped_coefficients = this_mod$coefficients
for (i in 1:(num_boot_samples-1)) {
  these_subjects = c(sample(boot_polygon_subjects,length(boot_polygon_subjects),replace=TRUE),sample(boot_modular_subjects,length(boot_modular_subjects),replace=TRUE),sample(boot_hybrid_subjects,length(boot_hybrid_subjects),replace=TRUE))
  this_model_data = do.call(rbind,lapply(these_subjects,function(i) model_data[model_data$subject == i,]))
  this_mod = glm(data=this_model_data, score_strict ~ question_type*condition+math_high)
  bootstrapped_coefficients = smartbind(bootstrapped_coefficients,this_mod$coefficients) #What inefficiency
} 
print("bootstrap done")
print(num_boot_samples)
print(proc.time()-tm)

print("Polygon:")
print("operation_6")
quantile(bootstrapped_coefficients$conditionpolygon,probs=c(0.025,0.975))
print("operation_9")
quantile(bootstrapped_coefficients$`question_typeoperation_9:conditionpolygon`,probs=c(0.025,0.975))
print("in_Z")
quantile(bootstrapped_coefficients$`question_typeinverse_zero_6:conditionpolygon`,probs=c(0.025,0.975))
print("in_NZ")
quantile(bootstrapped_coefficients$`question_typeinverse_nonzero_6:conditionpolygon`,probs=c(0.025,0.975))
quantile(bootstrapped_coefficients$`question_typeinverse_nonzero_9:conditionpolygon`,probs=c(0.025,0.975))
print("gen_T")
quantile(bootstrapped_coefficients$`question_typegenerator_true_6:conditionpolygon`,probs=c(0.025,0.975))
quantile(bootstrapped_coefficients$`question_typegenerator_true_9:conditionpolygon`,probs=c(0.025,0.975))
print("gen_TF")
quantile(bootstrapped_coefficients$`question_typegenerator_TF_n:conditionpolygon`,probs=c(0.025,0.975))


print("Hybrid:")
print("operation_6")
quantile(bootstrapped_coefficients$conditionhybrid,probs=c(0.025,0.975))
print("operation_9")
quantile(bootstrapped_coefficients$`question_typeoperation_9:conditionhybrid`,probs=c(0.025,0.975))
print("in_Z")
quantile(bootstrapped_coefficients$`question_typeinverse_zero_6:conditionhybrid`,probs=c(0.025,0.975))
print("in_NZ")
quantile(bootstrapped_coefficients$`question_typeinverse_nonzero_6:conditionhybrid`,probs=c(0.025,0.975))
quantile(bootstrapped_coefficients$`question_typeinverse_nonzero_9:conditionhybrid`,probs=c(0.025,0.975))
print("gen_T")
quantile(bootstrapped_coefficients$`question_typegenerator_true_6:conditionhybrid`,probs=c(0.025,0.975))
quantile(bootstrapped_coefficients$`question_typegenerator_true_9:conditionhybrid`,probs=c(0.025,0.975))
print("gen_TF")
quantile(bootstrapped_coefficients$`question_typegenerator_TF_n:conditionhybrid`,probs=c(0.025,0.975))
```
