---
title: "fyp_3_analysis_unified"
output: html_document
---
```{r}
library(rjson)
library(ggplot2)
library(tidyr)
library(dplyr)
library(lme4)
library(lmerTest)
library(boot)
library(stringr)
library(gtools) #smartbind
```


#Read files:
```{r}
data_location = "../data/fyp_3_data/" 
files = list.files(path = data_location,pattern="data_subject_.*.json")
modular_data = vector()
polygon_data = vector()
hybrid_data = vector()
#data frame building
subject = vector()
prompt = vector()
explain = vector()
explanation = vector()
correct_response = vector()
rt = vector()
response = vector()
condition = vector()
trial_index = vector()
score = vector()

j = 1
for (i in 1:length(files)) {
  path = paste(data_location,files[i],sep="")
  print(i)
  print(path)
  c = file(path, "r")
  l = readLines(c, -1L)
  close(c)
  these_data = lapply(X=l, fromJSON)
  if (these_data[1][[1]][[1]]$trial_type == "instructions") {
      this_condition = "modular"
      modular_data[length(modular_data) + 1] = these_data[1]
  } else {
    if (grepl("subtract",gsub(" ","",these_data[1][[1]][[1]]$instructions))) { 
        this_condition = "hybrid"
        hybrid_data[length(hybrid_data) + 1] = these_data[1]
    }
    else {
       this_condition = "polygon"
       polygon_data[length(polygon_data) + 1] = these_data[1]
    }
  }
  
  for (trial_i in 1:length(these_data[1][[1]])) {
    if(grepl("question",gsub(" ","",these_data[1][[1]][[trial_i]]$trial_type))) {
      subject[j] = i
      condition[j] = this_condition
      prompt[j] = these_data[1][[1]][[trial_i]]$question
      correct_response[j] = these_data[1][[1]][[trial_i]]$correct_response
      explain[j] = these_data[1][[1]][[trial_i]]$explain
      if (is.null(these_data[1][[1]][[trial_i]]$explanation) | is.list(these_data[1][[1]][[trial_i]]$explanation)) { #is.list handles the unfortunate partial matching of explanation to explanation_history when explanation is null
        explanation[j] = NA
      } else {
        explanation[j] = these_data[1][[1]][[trial_i]]$explanation
      }
      
      if (is.null(these_data[1][[1]][[trial_i]]$response)) {
        response[j] = NA
      }
      else {
        response[j] = these_data[1][[1]][[trial_i]]$response
      }
      
      if (!is.na(response[j]) && response[j] == correct_response[j]) {
        score[j] = 1
      } else {
        score[j] = 0        
      }
      rt[j] = these_data[1][[1]][[trial_i]]$rt
      trial_index[j] = trial_i
      
      j = j+1
    }
  }
}
```

Write data for scoring
----------------------------

```{r}
# #n-1,n-x
# write.table(complete_data[grepl("formula",gsub(" ","",complete_data$question)),c(1,4,5,8,10)],paste(data_location,"inverse_formula_to_score.csv",sep=''),sep=",")

# #Highest math class completed, 1 if algebra 2/trig/stats or higher, 0 else
# write.table(complete_data[grepl('mathclass',gsub(' ','',complete_data$question)),c(1,4,5,8,10)],paste(data_location,"highest_math_class_to_score.csv",sep=''),sep=",")

#NOT YET SCORED for explanations
# #n=9 operation questions
# write.table(complete_data[(grepl("Whatis8",gsub(" ","",complete_data$question)) | grepl("Whatis4",gsub(" ","",complete_data$question)))& grepl("explaininwords",gsub(" ","",complete_data$question)) ,c(1,3,4,5,7)],paste(data_location,"N9_operation_to_score.csv",sep=''),sep=",")
# 
# #n=9 generator questions
# write.table(complete_data[grepl("generatorunder",gsub(" ","",complete_data$question)) & (grepl("nonagon",gsub(" ","",complete_data$question)) | grepl("+<sub>9",gsub(" ","",complete_data$question)) ),c(1,3,4,5,7)],paste(data_location,"N9_generator_to_score.csv",sep=''),sep=",")
# 
# #n=9 inverse with explanations
# write.table(complete_data[grepl("inverseof3",gsub(" ","",complete_data$question)) & (grepl("nonagon",gsub(" ","",complete_data$question)) | grepl("+<sub>9",gsub(" ","",complete_data$question)) ),c(1,4,5,7)],paste(data_location,"N9_inverse_to_score.csv",sep=''),sep=",")
# 
# #generator T/F and A/S/N with explanations
# write.table(complete_data[grepl("explaininwords",gsub(" ","",complete_data$question)) & (grepl("Trueorfalse",gsub(" ","",complete_data$question)) | grepl("always,sometimes,ornever",gsub(" ","",complete_data$question))),c(1,4,5,7)],paste(data_location,"TF_ASN_explained_to_score.csv",sep=''),sep=",")


```

data frame building
------------------------
```{r}
complete_data = data.frame(subject=factor(subject),condition=condition,question=prompt,correct_response=correct_response,response=response,rt=rt,explain=explain,explanation=explanation,trial_index=trial_index,score=score) 

#Insert scored data
inverse_formula_scores = read.csv(paste(data_location,"inverse_formula_scored.csv",sep=""))
complete_data[inverse_formula_scores$row.names,]$score = inverse_formula_scores$score

#Strict scoring -- Some questions have "partial credit" of 0.5 for almost correct answers
complete_data = complete_data %>% mutate(score_strict = floor(score)) %>% 
  mutate(polygon=grepl("polygon",condition)) #Factors of condition


```

Change dummy coding to compare hybrid and polygon to modular.
```{r}
contrasts(complete_data$condition) = cbind(c(0,0,1),c(1,0,0))
colnames(contrasts(complete_data$condition)) = c('polygon','hybrid')
contrasts(complete_data$condition) 
```

Subject Demographics
-----------------

```{r}
subject_data = complete_data %>% 
  filter(grepl('education',gsub(" ","",question)) | grepl('yourgender',gsub(" ","",question)) ) %>%
  mutate(demographic_type = ifelse(grepl('education',gsub(" ","",question)),'education','gender')) %>%
  select(subject,demographic_type,response,polygon) %>%
  mutate(response = gsub(' ','',response)) %>%
  spread(demographic_type,response) %>%
  mutate(education_high = ifelse(grepl('Bachelors',education),1,ifelse(grepl('Masters',education),1,ifelse(grepl('graduate',education),1,ifelse(grepl('Doctorate',education),1,0)))))

highest_math_classes =read.csv(paste(data_location,"highest_math_class_scored.csv",sep=""))
subject_data$math_high = highest_math_classes$math_high
```

Subject exclusion
----------------------
Exclude subjects who responded 4 or higher on familiarity with modular arithmetic or mathematical groups: they know too much

```{r}
complete_unfiltered_data = complete_data
subjects_to_exclude = unique(complete_data[grepl("Howfamiliarareyou",gsub(" ","",complete_data$question)) & (grepl("4",complete_data$response) | grepl("5",complete_data$response)),]$subject)

complete_data = complete_unfiltered_data %>% filter(!(subject %in% subjects_to_exclude))


```

That's a lot of exclusions

Unified model - all 3 (Planned analysis)
---------------

```{r}
complete_data = complete_data %>% mutate(question_type = rep(NA,nrow(complete_data))) %>% inner_join(subject_data)

#Operation questions
complete_data[grepl("Remember,toperform",gsub(" ","",complete_data$question)),]$question_type = 'a_operation_6' #a is so it will appear at the beginning of models as reference level, to make life easier than manually altering the contrasts
complete_data[!(grepl("identity",gsub(" ","",complete_data$question)) | grepl("inverse",gsub(" ","",complete_data$question)) | grepl("generator",gsub(" ","",complete_data$question))) & (grepl("nonagon",gsub(" ","",complete_data$question)) | grepl("+<sub>9",gsub(" ","",complete_data$question)) ),]$question_type = 'operation_9'

#Inverse Questions -- Order 6
complete_data[grepl("Remember,theinverse",gsub(" ","",complete_data$question)),]$question_type = 'inverse_nonzero_6'
complete_data[grepl("Remember,theinverse",gsub(" ","",complete_data$question)) & complete_data$correct_response == '0',]$question_type = 'inverse_zero_6'
  
#Inverse Questions -- Order 9
complete_data[grepl("Whatistheinverse",gsub(" ","",complete_data$question)) & !grepl("Remember,theinverse",gsub(" ","",complete_data$question)),]$question_type = 'inverse_nonzero_9'
complete_data[grepl("Whatistheinverse",gsub(" ","",complete_data$question)) & !grepl("Remember,theinverse",gsub(" ","",complete_data$question)) & gsub(" ","",complete_data$correct_response) == '0',]$question_type = 'inverse_zero_9' 

#Inverse Questions -- order n
complete_data[inverse_formula_scores$row.names,]$question_type = 'inverse_formula_n'

#Generator Questions -- 6
complete_data[grepl("generatorunder",gsub(" ","",complete_data$question)) & (grepl("hexagon",gsub(" ","",complete_data$question)) | grepl("+<sub>6",gsub(" ","",complete_data$question)) ),]$question_type = 'generator_false_6'
complete_data[grepl("generatorunder",gsub(" ","",complete_data$question)) & (grepl("hexagon",gsub(" ","",complete_data$question)) | grepl("+<sub>6",gsub(" ","",complete_data$question)) ) & gsub(" ","",correct_response) == 'Yes',]$question_type = 'generator_true_6'

#Generator Questions -- 9
complete_data[grepl("generatorunder",gsub(" ","",complete_data$question)) & (grepl("nonagon",gsub(" ","",complete_data$question)) | grepl("+<sub>9",gsub(" ","",complete_data$question)) ),]$question_type = 'generator_false_9'
complete_data[grepl("generatorunder",gsub(" ","",complete_data$question)) & (grepl("nonagon",gsub(" ","",complete_data$question)) | grepl("+<sub>9",gsub(" ","",complete_data$question)) ) & (grepl('5',gsub(" ","",complete_data$question)) | grepl('2',gsub(" ","",complete_data$question))),]$question_type = 'generator_true_9'

#Generator T/F Questions -- n
complete_data[grepl("Trueorfalse",gsub(" ","",complete_data$question)),]$question_type = 'generator_TF_n'

#Generator A/S/N Questions -- n
complete_data[grepl("always,sometimes,ornever",gsub(" ","",complete_data$question)),]$question_type = 'generator_ASN_n'
```

```{r}
model_data = complete_data %>% filter(!is.na(question_type))
model_data$question_type = factor(model_data$question_type)
```

```{r}
model_data$condition = relevel(model_data$condition,ref='modular') #Because the previous doesn't seem to carry over
```

```{r}
tm = proc.time()
num_boot_samples = 10000
boot_polygon_subjects = unique(model_data[model_data$condition == 'polygon',]$subject)
boot_modular_subjects = unique(model_data[model_data$condition == 'modular',]$subject)
boot_hybrid_subjects = unique(model_data[model_data$condition == 'hybrid',]$subject)

#fencepost problem with coefficient storage
these_subjects = c(sample(boot_polygon_subjects,length(boot_polygon_subjects),replace=TRUE),sample(boot_modular_subjects,length(boot_modular_subjects),replace=TRUE),sample(boot_hybrid_subjects,length(boot_hybrid_subjects),replace=TRUE))
this_model_data = do.call(rbind,lapply(these_subjects,function(i) model_data[model_data$subject == i,]))
this_mod = glm(data=this_model_data, score_strict ~ question_type*condition+math_high)
bootstrapped_coefficients = this_mod$coefficients
for (i in 1:(num_boot_samples-1)) {
  these_subjects = c(sample(boot_polygon_subjects,length(boot_polygon_subjects),replace=TRUE),sample(boot_modular_subjects,length(boot_modular_subjects),replace=TRUE),sample(boot_hybrid_subjects,length(boot_hybrid_subjects),replace=TRUE))
  this_model_data = do.call(rbind,lapply(these_subjects,function(i) model_data[model_data$subject == i,]))
  this_mod = glm(data=this_model_data, score_strict ~ question_type*condition+math_high)
  bootstrapped_coefficients = smartbind(bootstrapped_coefficients,this_mod$coefficients) #What inefficiency
} 
print("bootstrap done")
print(num_boot_samples)
print(proc.time()-tm)

print("Polygon:")
print("operation_6")
quantile(bootstrapped_coefficients$conditionpolygon,probs=c(0.025,0.5,0.975))
this_mean = mean(bootstrapped_coefficients$conditionpolygon) # for meta analysis
this_se = sd(bootstrapped_coefficients$conditionpolygon) #for meta analysis
stuff = c('conditionpolygon',this_mean,this_se)
print("operation_9")
quantile(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typeoperation_9:conditionpolygon`,probs=c(0.025,0.5,0.975))
this_mean = mean(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typeoperation_9:conditionpolygon`)
this_se = sd(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typeoperation_9:conditionpolygon`)
stuff = rbind(stuff,c('question_typeoperation_9:conditionpolygon',this_mean,this_se))
print("in_Z")
quantile(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typeinverse_zero_6:conditionpolygon`,probs=c(0.025,0.5,0.975))
this_mean = mean(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typeinverse_zero_6:conditionpolygon`)
this_se = sd(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typeinverse_zero_6:conditionpolygon`)
stuff = rbind(stuff,c('question_typeinverse_zero_6:conditionpolygon',this_mean,this_se))
quantile(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typeinverse_zero_9:conditionpolygon`,probs=c(0.025,0.5,0.975))
this_mean = mean(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typeinverse_zero_9:conditionpolygon`)
this_se = sd(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typeinverse_zero_9:conditionpolygon`)
stuff = rbind(stuff,c('question_typeinverse_zero_9:conditionpolygon',this_mean,this_se))
print("in_NZ")
quantile(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typeinverse_nonzero_6:conditionpolygon`,probs=c(0.025,0.5,0.975))
this_mean = mean(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typeinverse_nonzero_6:conditionpolygon`)
this_se = sd(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typeinverse_nonzero_6:conditionpolygon`)
stuff = rbind(stuff,c('question_typeinverse_nonzero_6:conditionpolygon',this_mean,this_se))
quantile(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typeinverse_nonzero_9:conditionpolygon`,probs=c(0.025,0.5,0.975))
this_mean = mean(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typeinverse_nonzero_9:conditionpolygon`)
this_se = sd(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typeinverse_nonzero_9:conditionpolygon`)
stuff = rbind(stuff,c('question_typeinverse_nonzero_9:conditionpolygon',this_mean,this_se))
print("gen_T")
quantile(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typegenerator_true_6:conditionpolygon`,probs=c(0.025,0.5,0.975))
this_mean = mean(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typegenerator_true_6:conditionpolygon`)
this_se = sd(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typegenerator_true_6:conditionpolygon`)
stuff = rbind(stuff,c('question_typegenerator_true_6:conditionpolygon',this_mean,this_se))
quantile(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typegenerator_true_9:conditionpolygon`,probs=c(0.025,0.5,0.975))
this_mean = mean(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typegenerator_true_9:conditionpolygon`)
this_se = sd(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typegenerator_true_9:conditionpolygon`)
stuff = rbind(stuff,c('question_typegenerator_true_9:conditionpolygon',this_mean,this_se))
print("gen_TF")
quantile(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typegenerator_TF_n:conditionpolygon`,probs=c(0.025,0.5,0.975))
this_mean = mean(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typegenerator_TF_n:conditionpolygon`)
this_se = sd(bootstrapped_coefficients$conditionpolygon+bootstrapped_coefficients$`question_typegenerator_TF_n:conditionpolygon`)
stuff = rbind(stuff,c('question_typegenerator_TF_n:conditionpolygon',this_mean,this_se))


print("Hybrid:")
print("operation_6")
quantile(bootstrapped_coefficients$conditionhybrid,probs=c(0.025,0.5,0.975))
this_mean = mean(bootstrapped_coefficients$conditionhybrid) # for meta analysis
this_se = sd(bootstrapped_coefficients$conditionhybrid) #for meta analysis
stuff = rbind(stuff,c('conditionhybrid',this_mean,this_se))
print("operation_9")
quantile(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typeoperation_9:conditionhybrid`,probs=c(0.025,0.5,0.975))
this_mean = mean(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typeoperation_9:conditionhybrid`)
this_se = sd(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typeoperation_9:conditionhybrid`)
stuff = rbind(stuff,c('question_typeoperation_9:conditionhybrid',this_mean,this_se))
print("in_Z")
quantile(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typeinverse_zero_6:conditionhybrid`,probs=c(0.025,0.5,0.975))
this_mean = mean(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typeinverse_zero_6:conditionhybrid`)
this_se = sd(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typeinverse_zero_6:conditionhybrid`)
stuff = rbind(stuff,c('question_typeinverse_zero_6:conditionhybrid',this_mean,this_se))
quantile(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typeinverse_zero_9:conditionhybrid`,probs=c(0.025,0.5,0.975))
this_mean = mean(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typeinverse_zero_9:conditionhybrid`)
this_se = sd(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typeinverse_zero_9:conditionhybrid`)
stuff = rbind(stuff,c('question_typeinverse_zero_9:conditionhybrid',this_mean,this_se))
print("in_NZ")
quantile(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typeinverse_nonzero_6:conditionhybrid`,probs=c(0.025,0.5,0.975))
this_mean = mean(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typeinverse_nonzero_6:conditionhybrid`)
this_se = sd(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typeinverse_nonzero_6:conditionhybrid`)
stuff = rbind(stuff,c('question_typeinverse_nonzero_6:conditionhybrid',this_mean,this_se))
quantile(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typeinverse_nonzero_9:conditionhybrid`,probs=c(0.025,0.5,0.975))
this_mean = mean(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typeinverse_nonzero_9:conditionhybrid`)
this_se = sd(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typeinverse_nonzero_9:conditionhybrid`)
stuff = rbind(stuff,c('question_typeinverse_nonzero_9:conditionhybrid',this_mean,this_se))
print("gen_T")
quantile(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typegenerator_true_6:conditionhybrid`,probs=c(0.025,0.5,0.975))
this_mean = mean(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typegenerator_true_6:conditionhybrid`)
this_se = sd(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typegenerator_true_6:conditionhybrid`)
stuff = rbind(stuff,c('question_typegenerator_true_6:conditionhybrid',this_mean,this_se))
quantile(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typegenerator_true_9:conditionhybrid`,probs=c(0.025,0.5,0.975))
this_mean = mean(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typegenerator_true_9:conditionhybrid`)
this_se = sd(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typegenerator_true_9:conditionhybrid`)
stuff = rbind(stuff,c('question_typegenerator_true_9:conditionhybrid',this_mean,this_se))
print("gen_TF")
quantile(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typegenerator_TF_n:conditionhybrid`,probs=c(0.025,0.5,0.975))
this_mean = mean(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typegenerator_TF_n:conditionhybrid`)
this_se = sd(bootstrapped_coefficients$conditionhybrid+bootstrapped_coefficients$`question_typegenerator_TF_n:conditionhybrid`)
stuff = rbind(stuff,c('question_typegenerator_TF_n:conditionhybrid',this_mean,this_se))
```

```{r}
write.csv(stuff,file='fyp_3_bootstrap_estimates.csv')
```


Post-hoc 
------------------------------------

Subjects:
```{r}
table(complete_unfiltered_data[(complete_unfiltered_data$subject %in% subjects_to_exclude) & complete_unfiltered_data$trial_index == 3,]$condition)
complete_unfiltered_data[(complete_unfiltered_data$subject %in% subjects_to_exclude) & grepl("Howfamiliarareyou",gsub(" ","",complete_unfiltered_data$question)),c('subject','question','response')]
```



###Hierarchical modeling of hybrid condition data
```{r}
mod = lmer(data=model_data, score_strict ~ question_type*condition+math_high+(1|subject))
math_high_coefficient = summary(mod)$coefficients[16,1]
modular_coefficients = summary(mod)$coefficients[c(1:13),1]
polygon_coefficients = summary(mod)$coefficients[c(14,17:28),1]+modular_coefficients
perfect_combination_coefficients = pmax(polygon_coefficients,modular_coefficients)
```

```{r}
#print(paste(lapply(levels(model_data$question_type),function(x) return(paste(x,'=(question_type==\'',x,'\')',sep=''))),collapse=', '))
# print(paste(lapply(1:length(levels(model_data$question_type)),function(x) return(paste('coeffs[',x,']*',levels(model_data$question_type)[x],sep=''))),collapse='+'))
hierarchical_data = model_data %>% filter(condition == 'hybrid') %>%
  mutate(a_operation_6=(question_type=='a_operation_6'), generator_ASN_n=(question_type=='generator_ASN_n'), generator_false_6=(question_type=='generator_false_6'), generator_false_9=(question_type=='generator_false_9'), generator_TF_n=(question_type=='generator_TF_n'), generator_true_6=(question_type=='generator_true_6'), generator_true_9=(question_type=='generator_true_9'), inverse_formula_n=(question_type=='inverse_formula_n'), inverse_nonzero_6=(question_type=='inverse_nonzero_6'), inverse_nonzero_9=(question_type=='inverse_nonzero_9'), inverse_zero_6=(question_type=='inverse_zero_6'), inverse_zero_9=(question_type=='inverse_zero_9'), operation_9=(question_type=='operation_9'))

#Augment the data with weights and indicators for E-M algorithm
augmenting_frame = data.frame(theta=c(T,F,F),phi=c(NA,T,F),weight=c(1,1,1))
augmented_data = merge(hierarchical_data,augmenting_frame,by=NULL) 

#Subjects
hybrid_subjects = unique(hierarchical_data$subject)
```


```{r}
log_likelihood_of_data = function(data,coeffs) { #Given a fixed set of coefficients, calculates the log-likelihood of the data
  model = lm(data=data,score ~ 0+offset(math_high_coefficient*math_high+coeffs[1]+coeffs[2]*generator_ASN_n+coeffs[3]*generator_false_6+coeffs[4]*generator_false_9+coeffs[5]*generator_TF_n+coeffs[6]*generator_true_6+coeffs[7]*generator_true_9+coeffs[8]*inverse_formula_n+coeffs[9]*inverse_nonzero_6+coeffs[10]*inverse_nonzero_9+coeffs[11]*inverse_zero_6+coeffs[12]*inverse_zero_9+coeffs[13]*operation_9))
  return(logLik(model))
}

log_likelihood_of_full_data = function(data,theta,phi) {
  LL = 0.0
  for (subj in hybrid_subjects) {
    perfect_weight = theta*exp(log_likelihood_of_data(hierarchical_data[hierarchical_data$subject == subj,],perfect_combination_coefficients)[1])
    polygon_weight = (1-theta)*phi*exp(log_likelihood_of_data(hierarchical_data[hierarchical_data$subject == subj,],polygon_coefficients)[1])
    modular_weight = (1-theta)*(1-phi)*exp(log_likelihood_of_data(hierarchical_data[hierarchical_data$subject == subj,],modular_coefficients)[1])
    LL = LL+log(perfect_weight+polygon_weight+modular_weight)
  }
  return(LL)
}
```


Naive -- How well is data explained by assuming everybody just did one of three possibilities?
```{r}
print('polygon: ')
print(log_likelihood_of_full_data(hierarchical_data,0,1))
print('modular: ')
print(log_likelihood_of_full_data(hierarchical_data,0,0))
print('50-50 modular polygon: ')
print(log_likelihood_of_full_data(hierarchical_data,0,0.5))
print('max of the two: ')
print(log_likelihood_of_full_data(hierarchical_data,1,0))

```

Expectation-maximization
```{r}
#max number of iterations
num_iterations = 100
delta_LL_threshold =  0.0001
#initial values - uniform
theta = 0.5
phi = 0.5 

LL_hist = vector()

LL_hist[1] = log_likelihood_of_full_data(hierarchical_data,theta,phi)

for (iter in 1:num_iterations) {
  #E step
  for (subj in hybrid_subjects) {
    perfect_weight = theta*exp(log_likelihood_of_data(hierarchical_data[hierarchical_data$subject == subj,],perfect_combination_coefficients)[1])
    polygon_weight = (1-theta)*phi*exp(log_likelihood_of_data(hierarchical_data[hierarchical_data$subject == subj,],polygon_coefficients)[1])
    modular_weight = (1-theta)*(1-phi)*exp(log_likelihood_of_data(hierarchical_data[hierarchical_data$subject == subj,],modular_coefficients)[1])
    sum_weights = perfect_weight+polygon_weight+modular_weight
    augmented_data[augmented_data$subject == subj & augmented_data$theta,]$weight = perfect_weight/sum_weights
    augmented_data[augmented_data$subject == subj & !augmented_data$theta & augmented_data$phi,]$weight = polygon_weight/sum_weights
    augmented_data[augmented_data$subject == subj & !augmented_data$theta & !augmented_data$phi,]$weight = modular_weight/sum_weights
  }
  
  #M step
  theta = sum(augmented_data[augmented_data$theta,]$weight)/sum(augmented_data$weight)
  phi = sum(augmented_data[!augmented_data$theta & (augmented_data$phi==TRUE),]$weight)/sum(augmented_data[!augmented_data$theta,]$weight)
  
  #LL and termination
  LL_hist[iter+1] = log_likelihood_of_full_data(hierarchical_data,theta,phi)
  print(paste("theta: ",theta,", phi: ",phi,', LL: ',LL_hist[iter+1]))
  if (LL_hist[iter+1]-LL_hist[iter] < delta_LL_threshold) {
    print("Difference of log likelihood from previous step is below threshold, terminating.")
    break
  }
}

```



###Analysis of which representation problems

```{r}
data_location = "../data/fyp_3_data/" 
files = list.files(path = data_location,pattern="data_subject_.*.json")
modular_data = vector()
polygon_data = vector()
hybrid_data = vector()
#data frame building
subject = vector()
prompt = vector()
explain = vector()
explanation = vector()
correct_response = vector()
rt = vector()
response = vector()
condition = vector()
trial_index = vector()
score = vector()
whichrep_modular = vector()
whichrep_polygon = vector()



j = 1
for (i in 1:length(files)) {
  if (i %in% subjects_to_exclude) {
    next
  }
  path = paste(data_location,files[i],sep="")
  print(i)
  print(path)
  c = file(path, "r")
  l = readLines(c, -1L)
  close(c)
  these_data = lapply(X=l, fromJSON)
  if (these_data[1][[1]][[1]]$trial_type == "instructions") {
    next
  } else {
    if (grepl("subtract",gsub(" ","",these_data[1][[1]][[1]]$instructions))) { 
        this_condition = "hybrid"
        hybrid_data[length(hybrid_data) + 1] = these_data[1]
    }
    else {
       next

    }
  }
  
  for (trial_i in 1:length(these_data[1][[1]])) {
    temp = these_data[1][[1]][[trial_i]]$trial_type
    if((grepl("representation",gsub(" ","",temp)) && !grepl('demo',gsub(' ','',these_data[1][[1]][[trial_i]]$added_prompt))) || (grepl("question",gsub(" ","",temp)) && grepl('Pleaseanswer|Pleasedescribe',gsub(' ','',these_data[1][[1]][[trial_i]]$question)) && !grepl('demo',gsub(' ','',these_data[1][[1]][[trial_i]]$question)))) {
      
      subject[j] = i
      condition[j] = this_condition
      temp = these_data[1][[1]][[trial_i]]$question
      if (is.null(temp)) {
        if (grepl("representation",gsub(" ","",these_data[1][[1]][[trial_i]]$trial_type))) {
          prompt[j] = prompt[j-1]#Whichrep questions are about previously presented question
        } else {
          prompt[j] = NA
        }
      } else {
        prompt[j] = these_data[1][[1]][[trial_i]]$question
      }
      temp = these_data[1][[1]][[trial_i]]$correct_response
      if (is.null(temp)) {
        correct_response[j] = NA
      } else {
        correct_response[j] = these_data[1][[1]][[trial_i]]$correct_response
      }
      
      temp = these_data[1][[1]][[trial_i]]$explain
      if (is.null(temp)) {
        explain[j] = NA
      } else {
        explain[j] = these_data[1][[1]][[trial_i]]$explain
      }
      if (is.null(these_data[1][[1]][[trial_i]]$explanation) | is.list(these_data[1][[1]][[trial_i]]$explanation)) { #is.list handles the unfortunate partial matching of explanation to explanation_history when explanation is null
        explanation[j] = NA
      } else {
        explanation[j] = these_data[1][[1]][[trial_i]]$explanation
      }
      
      if (is.null(these_data[1][[1]][[trial_i]]$response)) {
        response[j] = NA
      }
      else {
        response[j] = these_data[1][[1]][[trial_i]]$response
      }
      
      if (!is.na(response[j]) && response[j] == correct_response[j]) {
        score[j] = 1
      } else {
        score[j] = 0        
      }
     
      #scores for whichrep 
      if (grepl("representation",gsub(" ","",these_data[1][[1]][[trial_i]]$trial_type))) {
        score[j] = score[j-1]#Whichrep questions are about previously presented question
      } else if (grepl("describe",gsub(" ","",these_data[1][[1]][[trial_i]]$question))) {
        score[j] = score[j-2]#Whichrep descriptions are about question 2 back
      }
      
      
      #whichrep questions
      if (is.null(these_data[1][[1]][[trial_i]]$modular_response)) {
        whichrep_modular[j] = NA
      } else {
        whichrep_modular[j] = these_data[1][[1]][[trial_i]]$modular_response
      }
      
      if (is.null(these_data[1][[1]][[trial_i]]$polygon_response)) {
        whichrep_polygon[j] = NA
      } else {
        whichrep_polygon[j] = these_data[1][[1]][[trial_i]]$polygon_response
      }
      
      rt[j] = these_data[1][[1]][[trial_i]]$rt
      trial_index[j] = trial_i
      
      j = j+1
    }
  }
}
```

```{r}
whichrep_data = data.frame(subject=factor(subject),condition=condition,question=prompt,correct_response=correct_response,response=response,rt=rt,explain=explain,explanation=explanation,trial_index=trial_index,score=score,whichrep_modular,whichrep_polygon)
whichrep_data$whichrep_modular = as.numeric(levels(whichrep_data$whichrep_modular))[whichrep_data$whichrep_modular]
whichrep_data$whichrep_polygon = as.numeric(levels(whichrep_data$whichrep_polygon))[whichrep_data$whichrep_polygon]
```

```{r}
#inverse zero
wr_mod_in0 = glm(score ~ whichrep_modular + whichrep_polygon,data=whichrep_data[!is.na(whichrep_data$whichrep_modular) & grepl('inverseof0',gsub(' ','',whichrep_data$question)),],family='binomial')
summary(wr_mod_in0)

wr_mod_innz = glm(score ~ whichrep_modular + whichrep_polygon,data=whichrep_data[!is.na(whichrep_data$whichrep_modular) & grepl('inverseof4',gsub(' ','',whichrep_data$question)),],family='binomial')
summary(wr_mod_innz)

wr_mod_gen = glm(score ~ whichrep_modular + whichrep_polygon,data=whichrep_data[!is.na(whichrep_data$whichrep_modular) & grepl('4agenerator',gsub(' ','',whichrep_data$question)),],family='binomial')
summary(wr_mod_gen)


wr_mod_gen_TF = glm(score ~ whichrep_modular + whichrep_polygon,data=whichrep_data[!is.na(whichrep_data$whichrep_modular) & grepl('Trueorfalse',gsub(' ','',whichrep_data$question)),],family='binomial')
summary(wr_mod_gen_TF)
```

```{r}
whichrep_data$score = factor(whichrep_data$score)

ggplot(data=whichrep_data[!is.na(whichrep_data$whichrep_modular) & grepl('inverseof0',gsub(' ','',whichrep_data$question)),],aes(whichrep_modular)) +
  geom_histogram(binwidth=1) +
  theme_bw()

ggplot(data=whichrep_data[!is.na(whichrep_data$whichrep_polygon) & grepl('inverseof0',gsub(' ','',whichrep_data$question)),],aes(whichrep_polygon)) +
  geom_histogram(binwidth=1) +
  theme_bw()

ggplot(data=whichrep_data[!is.na(whichrep_data$whichrep_polygon) & grepl('inverseof0',gsub(' ','',whichrep_data$question)),],aes(x=whichrep_polygon,y=whichrep_modular,color=score)) +
  geom_point(position=position_jitter()) +
  theme_bw()

ggplot(data=whichrep_data[!is.na(whichrep_data$whichrep_modular) & grepl('inverseof4',gsub(' ','',whichrep_data$question)),],aes(whichrep_modular)) +
  geom_histogram(binwidth=1) +
  theme_bw()

ggplot(data=whichrep_data[!is.na(whichrep_data$whichrep_polygon) & grepl('inverseof4',gsub(' ','',whichrep_data$question)),],aes(whichrep_polygon)) +
  geom_histogram(binwidth=1) +
  theme_bw()

ggplot(data=whichrep_data[!is.na(whichrep_data$whichrep_polygon) & grepl('inverseof4',gsub(' ','',whichrep_data$question)),],aes(x=whichrep_polygon,y=whichrep_modular,color=score)) +
  geom_point(position=position_jitter()) +
  theme_bw()

ggplot(data=whichrep_data[!is.na(whichrep_data$whichrep_modular) & grepl('4agenerator',gsub(' ','',whichrep_data$question)),],aes(whichrep_modular)) +
  geom_histogram(binwidth=1) +
  theme_bw()

ggplot(data=whichrep_data[!is.na(whichrep_data$whichrep_polygon) & grepl('4agenerator',gsub(' ','',whichrep_data$question)),],aes(whichrep_polygon)) +
  geom_histogram(binwidth=1) +
  theme_bw()

ggplot(data=whichrep_data[!is.na(whichrep_data$whichrep_polygon) & grepl('4agenerator',gsub(' ','',whichrep_data$question)),],aes(x=whichrep_polygon,y=whichrep_modular,color=score)) +
  geom_point(position=position_jitter()) +
  theme_bw()

ggplot(data=whichrep_data[!is.na(whichrep_data$whichrep_modular) & grepl('Trueorfalse',gsub(' ','',whichrep_data$question)),],aes(whichrep_modular)) +
  geom_histogram(binwidth=1) +
  theme_bw()

ggplot(data=whichrep_data[!is.na(whichrep_data$whichrep_polygon) & grepl('Trueorfalse',gsub(' ','',whichrep_data$question)),],aes(whichrep_polygon)) +
  geom_histogram(binwidth=1) +
  theme_bw()

ggplot(data=whichrep_data[!is.na(whichrep_data$whichrep_polygon) & grepl('Trueorfalse',gsub(' ','',whichrep_data$question)),],aes(x=whichrep_polygon,y=whichrep_modular,color=score)) +
  geom_point(position=position_jitter()) +
  theme_bw()


```


